<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Defense on XS-Leaks Wiki</title><link>https://xsleaks.dev/category/defense/</link><description>Recent content in Defense on XS-Leaks Wiki</description><generator>Hugo 0.125.1</generator><language>en-us</language><lastBuildDate>Fri, 05 Nov 2021 23:41:07 +0000</lastBuildDate><atom:link href="https://xsleaks.dev/category/defense/index.xml" rel="self" type="application/rss+xml"/><item><title>Resource Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</guid><description>Resource Isolation Policy prevents external websites from requesting your resources. Blocking such traffic mitigates common web vulnerabilities such as CSRF, XSSI, or XS-Leaks. The policy can be enabled for applications whose endpoints are not intended to be loaded in a cross-site context and will allow resource requests coming from your application as well as direct navigations.
Implementation with Fetch Metadata # The below snippet showcases an example implemention of the Resource Isolation Policy with the use of Fetch Metadata headers:</description></item><item><title>Framing Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</guid><description>Framing Isolation Policy is a stricter version of Framing Protections where the request gets blocked at the application level rather than by the browser. This is designed to protect against various attacks (e.g. XSSI, CSRF, XS-Leaks) by blocking framing requests to endpoints that are not intended to be framable.
It can be combined with Resource Isolation Policy to effectively tighten the attack surface within cross-site information leaks.
tip
Instead of rejecting all non-framable endpoints, the user could be prompted to confirm the action, e.</description></item><item><title>Navigation Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</guid><description>Navigation Isolation Policy is a server-side protection mechanism intended to mitigate CSRF, clickjacking, reflected XSS, and XS-Leaks that make use of cross-site window contexts. This is a strict policy and has the potential to break an application since it blocks all cross-site navigations, including navigations through hyperlinks.
tip
Instead of rejecting all cross-site interactions, the user could be prompted to confirm the action, e.g. Confirm that you visited this page from a trusted origin, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.</description></item><item><title>Strict Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</guid><description>Strict Isolation Policy is intended to protect against all cross-site interactions (including navigations to the application through hyperlinks). This is a very strict policy that has the potential to prevent applications from functioning properly.
tip
Instead of rejecting all cross-site interactions, the user could be prompted to confirm the action, e.g. Confirm that you visited this page from a trusted origin, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.</description></item><item><title>Fetch Metadata</title><link>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</guid><description>Fetch Metadata Request Headers are sent by browsers with HTTPS requests. These headers provide context on how a request was initiated so that applications are able to make more informed decisions on how to respond to them. This allows servers to behave differently when they detect potential attacks (e.g. unexpected cross-origin requests)[^1]. This can be very effective against cross-origin attacks like XSSI, XS-Leaks, Clickjacking, and CSRF if a strict policy is deployed on the server.</description></item><item><title>Cache Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</guid><description>There are a number of different approaches applications can use to defend against cache probing-based XS-Leaks. These approaches are explained in the following sections.
Cache Protection via Cache-Control Headers # If it is acceptable to disable caching, doing so provides a strong defense against cache probing attacks. Disabling caching means that every time someone loads a resource, the resource has to be fetched again. To disable caching, set a Cache-Control: no-store header on every single response that you wish to protect.</description></item><item><title>Cross-Origin Read Blocking</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</guid><description>Cross-Origin Read Blocking (CORB) is a security mechanism that prevents attackers from loading certain cross-origin resources 1. This protection was created to defend against speculative side-channel attacks such as Spectre that allow attackers to read the memory of the process that both cross-site pages (e.g. attacker.com and sensitive.com) were embedded into. CORB aims to prevent attackers from loading certain sensitive cross-origin resources into an attacker-controlled process. For example, if an attacker tries to load cross-origin HTML, XML, or JSON into an img tag, CORB prevents this from happening.</description></item><item><title>Cross-Origin-Opener-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/coop/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/coop/</guid><description>Getting access to a website&amp;rsquo;s window object is a common prerequisite for different XS-Leak techniques. Framing Protections can ensure that an attacker cannot use iframes to access the window object, but this does not stop an attacker from accessing the window object from an opened window through window.open(url) or window.opener references.
Exploiting XS-Leaks with window.open is generally seen as the least appealing option for an attacker because the user can see it happen in the open browser window.</description></item><item><title>Cross-Origin-Resource-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/corp/</guid><description>Cross-Origin Resource Policy (CORP) is a web platform security feature that allows websites to prevent certain resources from being loaded by other origins. This protection complements CORB since it is an opt-in defense, whereas CORB blocks some cross-origin reads by default. CORP is designed to protect against both speculative execution attacks and XS-Leaks by allowing developers to ensure that sensitive resources cannot end up in attacker-controlled processes. Unlike CORB, this protection is enforced in the browser only if an application opts in to the protection.</description></item><item><title>Framing Protections</title><link>https://xsleaks.dev/docs/defenses/opt-in/xfo/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/xfo/</guid><description>A considerable number of XS-Leaks rely on some of the properties of iframes. If an attacker is unable to embed the contents of a page as an iframe, frame, embed or object, then the attack may no longer be possible. To mitigate XS-Leaks which rely on these objects, pages can forbid or select which origins can embed them. Doing so is possible by using the X-Frame-Options header or the CSP frame-ancestors directive.</description></item><item><title>Partitioned HTTP Cache</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</guid><description>In order to defend against cache probing attacks, browser developers are actively working on implementing a partitioned HTTP cache functionality that would in essence ensure each website has a distinct cache. Since cache probing relies on the fact that a browser&amp;rsquo;s HTTP cache is shared across every website, a partitioned HTTP cache can defend against many cache probing techniques. This is done by using tuples (either (top-frame-site, resource-url) like firefox 1 or (top-frame-site, framing-site, resource-url)) like chromium/chrome 2 as the cache keys to ensure the cache is partitioned by the requesting site.</description></item><item><title>SameSite Cookies</title><link>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</guid><description>SameSite cookies are one of the most impactful modern security mechanisms for fixing security issues that involve cross-site requests. This mechanism allows applications to force browsers to only include cookies in requests that are issued same-site 1. This type of cookie has three modes: None, Lax, and Strict.
SameSite Cookie Modes # The following SameSite cookie modes are available:
None – Disables all protections and restores the old behavior of cookies.</description></item><item><title>Subresource Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</guid><description>The fundamental idea behind designing protections for subresources is that subresources cannot be targeted by XS-Leaks if the attacker cannot make them return any user data. If implemented correctly, this approach can be a very strong defense, though it is likely to be tough to implement and could negatively impact the user experience.
tip
It can be very effective to deploy this approach on any specific resources that are known to be especially sensitive to XS-Leaks.</description></item><item><title>Document Policies</title><link>https://xsleaks.dev/docs/defenses/opt-in/document-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/document-policies/</guid><description>Document-Policy is an experimental mechanism, similar to another experimental Feature Policy 1, used to cover features which are more about configuring a document, or removing features (sandboxing) from a document or a frame. 2 It can be for example set in a header response as shown in the example below.
example
Document-Policy: unsized-media=?0, document-write=?0, max-image-bpp=2.0, frame-loading=lazy ForceLoadAtTop # The ForceLoadAtTop feature provides an opt-out for Scroll To Text (and other load-on-scroll behaviors) for privacy sensitive sites.</description></item></channel></rss>